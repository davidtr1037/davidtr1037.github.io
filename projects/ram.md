---
layout: page
title: Relocatable Addressing Model
permalink: /ram/
---
___
### Source Code
The source code (including a replication package) will be released soon.

### Replication Package

#### Environment

The experiments were run on a Ubuntu 16.04 machine, with Intel i7-6700 processor (8 cores) and 32GB of RAM.
Note that building LLVM takes usualy 15-30 minutes (depending on your hardware and how many cores you use),
so please take that into considiration.
The rest of the dependencis are built relatively quickly.

#### Build & Install
To build our extension, follow the instructions at _TBD_.

_Building Baseline KLEE_
```
cd <root>/code/klee-vanilla-build/
./configure.sh
make
```

_Building SMM KLEE_

First, build SVF:
```
cd <root>/code
git clone https://github.com/kren1/SVF.git
cd SVF
git checkout fix_pta_delete
mkdir build
cd build
LLVM_DIR=../../llvm-7.0.0.obj/ cmake ..
make
cp lib/Svf.so lib/libSvf.so
cp lib/CUDD/Cudd.so lib/CUDD/libCudd.so
```

And then:
```
cd <root>/code/klee-smm-build/
./configure.sh
make
```

_Our Tool_

To build our tool which is an extension of KLEE, do the following:
```
cd <root>/code/klee-tool-build/
./configure.sh
make
```
Update the PATH variable:
```
export PATH=<root>/code/klee-tool-build/bin:$PATH
```

#### Usage and example
Our tool is an extension of KLEE, to which we added several new command line options.
The main options are:
- _use-sym-addr_: use the addressing model described in the paper (section 2.2)
- _use-rebase_: enable dynamic merging of memory objects (section 2.3)
- _split-objects_: enable dynamic splitting of memory objects (section 2.4)
- _split-threshold=N_: split objects larger than _N_ bytes (section 2.4)
- _partition-size=N_: set the size of the split objects (section 2.4)

For a simple example, we provide the following C program:
```
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <klee/klee.h>

#define N (4)

typedef struct {
    int k;
    char data[512];
} object_t;

int main(int argc, char *argv[]) {
    object_t **array = calloc(N, sizeof(object_t *));
    for (unsigned int i = 0; i < N; i++) {
        array[i] = calloc(sizeof(object_t), 1);
    }

    unsigned int i = klee_range(0, N, "i");
    if (array[i]->k == 0) {
        printf("OK\n");
    }

    unsigned int k = klee_range(0, N, "k");
    if (array[k]->k == 0) {
        printf("OK\n");
    }

    return 0;
}
```

Analyzing with baseline KLEE:
```
klee -libc=uclibc -search=dfs -allocate-determ -allocate-determ-start-address=0x0 <bitcode_file>
```
Analyzing with our addressing model with merging:
```
klee -libc=uclibc -search=dfs -allocate-determ -allocate-determ-start-address=0x0 -use-sym-addr -use-rebase <bitcode_file>
```
Analyzing with our addressing model with splitting:
```
klee -libc=uclibc -search=dfs -allocate-determ -allocate-determ-start-address=0x0 -use-sym-addr -split-objects -split-threshold=128 -partition-size=64 <bitcode_file>
```

#### Benchmarks

The benchmarks are located at the __root__/benchmarks directory.
The bitcode files (.bc) of the programs are already built.
If needed, you can build them as follows:

m4:
```
make all
```
make:
```
make all
```
sqlite:
```
make all
```
apr:
```
make test_driver.bc
```
gas (GNU assembler):
```
make all
```
libxml2:
```
make test_driver.bc
```
coreutils:
```
make all
./extract.sh
```

#### Traces

We provide the traces for our experiments in __TBD__.
The traces are the __klee_out-__ directories generated by KLEE.

For section 4.1:
```
python parse_overhead.py traces/overhead
```
The directory __traces/overhead__ contains output directories of the form:
```
out-klee-<program>
out-mm-<program> // our addressing model
```
For table 3:

The directory __traces/merge/models__ contains output directories of the form _out-mode-search_.
```
python parse_models.py traces/merge/models
```
For table 4:

The directory __traces/merge/resolve-queries__ contains output directories of the form _out-kN_ (for N=0,1,2,3,4) and _out-default_.
```
python parse_resolve_queries.py traces/merge/resolve-queries
```
For table 5:

The directory __traces/merge/optimizations__ contains output directories of the form _out-no-opt_, _out-opt-context_, _out-opt-reuse_.
```
python parse_opts.py traces/merge/optimizations
```
For table 7:

The directory __traces/split__ contains output directories of the form _out-split-pN_ (for N=32,64,128,256,512) and _out-split-vanilla_.
```
python parse_opts.py traces/split
```
#### Experiments

__Configuration__

First, initialize the output directory which will contain the results of the experiments (klee-out directories):
```
<root>/benchmarks/init_artifact_dir.sh <full-path-to-new-output-dir>
```
Before running the experiments, we will need to set some variables in __root__/benchmarks/config.sh:
```
VANILLA_KLEE=<root>/code/klee-vanilla-build/bin/klee
KLEE_SMM=<root>/code/klee-smm-build/bin/klee
KLEE=<root>/code/klee-tool-build/bin/klee
ARTIFACT_DIR=<full-path-to-new-output-dir>
```

__Correctness and overhead__

Run the following command:
```
<root>/benchmarks/run_overhead_all.sh
```
To parse the results:
```
python parse_overhead.py <full-path-to-new-output-dir>/overhead
```

__Merging__

For the experiment related to Table 3, we run in 3 different memory models:
Forking memory model:
```
<root>/benchmarks/run_fmm_all.sh
```
Segmented memory model:
```
<root>/benchmarks/run_smm_all.sh
```
Dynamically segmented memory model:
```
<root>/benchmarks/run_dsmm_all.sh
```
To parse the results:
```
python parse_models.py <full-path-to-new-output-dir>/merge/models
```

__Resolution Queries__

For the experiment related to Table 4, do the following:
```
<root>/benchmarks/run_resolve_all.sh
```
To parse the results:
```
python parse_resolve_queries.py <full-path-to-new-output-dir>/merge/resolve-queries
```

__Optimizations__

For the experiment related to Table 5, do the following:
```
<root>/benchmarks/run_opts_all.sh
```
To parse the results:
```
python parse_opts.py <full-path-to-new-output-dir>/merge/optimizations
```


__Splitting__

For the experiment related to Table 7, do the following:
```
<root>/benchmarks/run_split_all.sh
```
To parse the results:
```
python parse_opts.py <full-path-to-new-output-dir>/split
```
